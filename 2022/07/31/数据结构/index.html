<!DOCTYPE html>
<html lang="zh-CN">
<head>
  
  <!--将该代码放入博客模板的head中即可-->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
  });
  </script>
  <!--latex数学显示公式-->
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 6.2.0">

  

  

  
    <meta name="author" content="Ztemily">
  

  

  

  <title>数据结构 | 未决天</title>

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
  

  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(https://s1.328888.xyz/2022/06/09/CJSfd.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          未决天
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">数据结构</h1>
          <h2 class="title-sub-wrap">
            <strong>Ztemily</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2022-07-30T22:59:55.000Z" itemprop="datePublished">2022-07-31</time>
          </h2>
          <ul class="wrap-list dark">
  
</ul>
          <ul class="wrap-list dark">
  
    <li><a href="/tags/OI/">🏷️ OI</a></li>
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <h1 id="平衡树"><a class="markdownIt-Anchor" href="#平衡树"></a> 平衡树</h1>
<p>我们需要维护一种数据结构，支持以下操作：插入值，删除值，查询数在集合中的排名，查询排名为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的数，求某个数的前驱与后继。</p>
<p>我们可以用二叉搜索树维护，但是可以被卡成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ，那么我们要用到另外一种数据结构，即平衡树来维护这些操作。</p>
<p>平衡树种类较多，这里仅介绍其中的Splay、Treap、FHQ Treap。</p>
<h2 id="splay"><a class="markdownIt-Anchor" href="#splay"></a> Splay</h2>
<p>平衡树是基于BST也就是二叉搜索树的结构来进行维护的，它有一些性质。</p>
<p>左儿子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 根 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 右儿子，这里的小于号可以自定义。且中序遍历可以得到一个有序序列。</p>
<p>我们在正常情况下显然可以用BST的特性去跳左右儿子就可以找到目标节点，但是在链数据下会从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> 复杂度卡成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>那么，Splay就是通过其独特的旋转操作，用旋学来稳定玄学的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 复杂度。</p>
<p>关于每个节点我们需要存储的信息有这些：父节点与子节点编号，权值，权值出现次数与此节点所在子树的大小。</p>
<p>那么我们可以写出维护其基本性质的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(x) son[x][0]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(x) son[x][1]</span><br><br><span class="hljs-type">int</span> fa[Maxn], son[Maxn][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> val[Maxn], cnt[Maxn];<br><span class="hljs-type">int</span> siz[Maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ls</span>(x) = <span class="hljs-built_in">rs</span>(x) = f[x] = siz[x] = cnt[x] = val[x] = <span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br>&#125; <span class="hljs-comment">//删除节点</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">rs</span>(f[x]) == x);<br>&#125; <span class="hljs-comment">//判断节点是左儿子还是右儿子</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x)<br>    &#123;<br>        siz[x] = cnt[x];<br>        <span class="hljs-built_in">ls</span>(x) ? siz[x] += siz[<span class="hljs-built_in">ls</span>(x)] : siz[x] = siz[x];<br>        <span class="hljs-built_in">rs</span>(x) ? siz[x] += siz[<span class="hljs-built_in">rs</span>(x)] : siz[x] = siz[x];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-comment">//上传</span><br></code></pre></td></tr></table></figure>
<p>那么下一步就是Splay的精髓所在——旋转。</p>
<p>我们根据不同的情况去调整，直到我们需要的节点转到了根节点处</p>
<p>旋转的过程也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 节点逐渐向根结点逼近的过程。那么我们每次旋转的时候去考虑将其旋转到它父节点的位置来向上逼近。</p>
<p>手玩一下可得，我们需要把从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到根节点上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">fa[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 连接的边都删掉，然后把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">fa[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 连成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的右儿子以维护BST性质，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 点存在右子树，那么就把它连到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">fa[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 的左子树上，最后再更新一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">fa[fa[x]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 的左儿子即可。</p>
<p>但是在 $ x、fa[x]、fa[fa[x]] $ 共线的情况下，如果仍然按照从下往上的顺序转，那么我们的链结构会被破坏从而导致失衡。此时就需要用双旋去平衡，其实也就是先转父节点再转子节点，最终就可以达到我们想要的结果。</p>
<p>最后不要忘了上传。</p>
<p>即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fx = f[x], gfx = f[fx];<br>    <span class="hljs-type">int</span> c = <span class="hljs-built_in">get</span>(ix);<br>    f[x] = gfx;<br>    f[fx] = x;<br>    son[fx][c] = ch[x][c ^ <span class="hljs-number">1</span>];<br>    son[x][c ^ <span class="hljs-number">1</span>] = fx;<br>    <span class="hljs-keyword">if</span> (son[x][c ^ <span class="hljs-number">1</span>])<br>        fa[son[x][c ^ <span class="hljs-number">1</span>]] = fx;<br>    <span class="hljs-keyword">if</span> (gfx)<br>        son[gfx][<span class="hljs-built_in">get</span>(fx)] = x;<br>    <span class="hljs-built_in">up</span>(fx);<br>    <span class="hljs-built_in">up</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (fa[x])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fa[fa[x]])<br>            <span class="hljs-built_in">rotate</span>(<span class="hljs-built_in">get</span>(x) == <span class="hljs-built_in">get</span>(fa[x]) ? fa[x] : x);<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br>    rt = x;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么接下来的操作就好说了，我们已经维护好了性质，只需要利用我们构建的优美的平衡结构即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">rt_pre</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">ls</span>(rt);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">rs</span>(x))<br>        x = <span class="hljs-built_in">rs</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">rt_nxt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">rs</span>(x);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">ls</span>(x))<br>        x = <span class="hljs-built_in">ls</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = rt, f = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i <span class="hljs-keyword">and</span> val[i] != x)<br>        f = i, i = son[i][x &gt; val[i]];<br><br>    <span class="hljs-keyword">if</span> (i)<br>        cnt[i]++;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        i = tot++;<br>        cnt[tot] = siz[tot] = <span class="hljs-number">1</span>;<br>        val[tot] = x;<br>        fa[tot] = f;<br>        <span class="hljs-keyword">if</span> (f)<br>            son[f][x &gt; cal[f]] = i;<br>    &#125;<br><br>    <span class="hljs-built_in">up</span>(i);<br>    <span class="hljs-built_in">up</span>(fa[i]);<br><br>    <span class="hljs-keyword">if</span> (!rt)<br>        rt = i;<br>    <span class="hljs-built_in">splay</span>(i);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = rt;<br>    <span class="hljs-keyword">while</span> (i <span class="hljs-keyword">and</span> val[i] != x)<br>        i = son[i][x &gt; val[i]];<br><br>    <span class="hljs-keyword">if</span> (!i)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">splay</span>(i);<br><br>    <span class="hljs-keyword">if</span> (!(--cnt[i]))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ls</span>(i) <span class="hljs-keyword">and</span> !<span class="hljs-built_in">rs</span>(i))<br>            <span class="hljs-built_in">clear</span>(i), rt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ls</span>(i))<br>            rt = <span class="hljs-built_in">rs</span>(i), fa[rt] = <span class="hljs-number">0</span>, <span class="hljs-built_in">clear</span>(i);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">rs</span>(i))<br>            rt = <span class="hljs-built_in">ls</span>(i), fa[rt] = <span class="hljs-number">0</span>, <span class="hljs-built_in">clear</span>(i);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> p = <span class="hljs-built_in">rt_pre</span>();<br>            <span class="hljs-built_in">rs</span>(p) = <span class="hljs-built_in">rs</span>(i);<br>            fa[<span class="hljs-built_in">rs</span>(i)] = p;<br>            <span class="hljs-built_in">clear</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">up</span>(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">rk</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, i = rt;<br>    <span class="hljs-keyword">while</span> (i <span class="hljs-keyword">and</span> val[i] != x)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; val[i])<br>            i = <span class="hljs-built_in">ls</span>(i);<br>        <span class="hljs-keyword">else</span><br>            res += siz[<span class="hljs-built_in">ls</span>(i)] + cnt[i], i = <span class="hljs-built_in">rs</span>(i);<br>    &#125;<br><br>    res += siz[<span class="hljs-built_in">ls</span>(i)];<br>    <span class="hljs-built_in">splay</span>(i);<br>    <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = rt;<br>    <span class="hljs-keyword">while</span> (i)<br>    &#123;<br>        <span class="hljs-type">int</span> lcnt = siz[<span class="hljs-built_in">ls</span>(i)];<br>        <span class="hljs-keyword">if</span> (lcnt &lt; k <span class="hljs-keyword">and</span> k &lt;= lcnt + cnt[i])<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt;= lcnt)<br>            i = <span class="hljs-built_in">ls</span>(i);<br>        <span class="hljs-keyword">else</span><br>            k -= lcnt + cnt[i], i = <span class="hljs-built_in">rs</span>(i);<br>    &#125;<br><br>    <span class="hljs-built_in">splay</span>(i);<br>    <span class="hljs-keyword">return</span> val[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getpre</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = (<span class="hljs-built_in">insert</span>(x), <span class="hljs-built_in">rt_pre</span>());<br>    <span class="hljs-built_in">erase</span>(x);<br>    <span class="hljs-keyword">return</span> val[res];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getnxt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = (<span class="hljs-built_in">insert</span>(x), <span class="hljs-built_in">rt_nxt</span>());<br>    <span class="hljs-built_in">erase</span>(x);<br>    <span class="hljs-keyword">return</span> val[res];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="treap"><a class="markdownIt-Anchor" href="#treap"></a> Treap</h2>
<p>树与堆的结合。</p>
<p>利用了堆的性质保证了树结构的平衡，即层数达到期望 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 。</p>
<p>Treap的每个节点需要一个额外的权值作为优先级，去维护它作为堆的性质。因此整棵树不仅要符合BST的特性，也要满足父节点的额外权值大于两个子节点。</p>
<p>我们一般设此权值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ord</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> ，且是随机生成，因此Treap是一种弱平衡的结构。</p>
<p>Treap有两种实现形式，我们一一讲解。</p>
<h3 id="带旋treap"><a class="markdownIt-Anchor" href="#带旋treap"></a> 带旋Treap</h3>
<p>是Treap的最初形式，用“左旋”与“右旋”去维护平衡，但它不支持区间操作。</p>
<p>我们去定义一些存储结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(x) son[x][0]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(x) son[x][1]</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> fa[Maxn], son[Maxn][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> val[Maxn], cnt[Maxn];<br><span class="hljs-type">int</span> siz[Maxn];<br><span class="hljs-type">int</span> ord[Maxn];<br></code></pre></td></tr></table></figure>
<p>带旋的Treap常数较小且不容易卡，因为我们会对每一个节点去随机出来一个值作为堆的优先级，同时在每次删除或者插入时根据这个权值去决定旋转与否。</p>
<p>旋转：</p>
<p>我们需要在不影响树的性质的前提之下，把和旋转方向相反的子树变为根，把原来根结点作为与旋转方向相同的子节点，且左旋与右旋操作是相互的。</p>
<p>那么就根据堆的性质往上转即可，因为是小根堆，那么上面的优先级一定会更小。最终也就是让左子节点或者右子节点变为根结点即可。</p>
<pre><code>        A                 C
       / \               / \
      B   C    ----&gt;    A   E
         / \           / \
        D   E         B   D
</code></pre>
<p><img src="https://oi-wiki.org/ds/images/treap-rotate.svg" alt="" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> siz[x]=siz[<span class="hljs-built_in">ls</span>(x)]+siz[<span class="hljs-built_in">rs</span>(x)]+<span class="hljs-number">1</span>,<span class="hljs-built_in">void</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">spin</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=s[i][p];<br>    s[i][p]=s[t][!p];<br>    s[t][!p]=i;<br>    <span class="hljs-built_in">up</span>(i); <span class="hljs-built_in">up</span>(t);<br>    i=t;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>插入和普通的BST没啥太大区别，只需要注意要通过旋转来维护堆的性质。至于删除的话就大力分类讨论即可，考虑删除后谁适合当父节点，且要注意更改树的大小。</p>
<p>然后我们就可以再次利用构建的性质去进行操作。</p>
<p>注意从根结点开始递归。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!i)<br>    &#123;<br>        i = ++tot;<br>        siz[i] = <span class="hljs-number">1</span>;<br>        val[i] = x, pri[i] = <span class="hljs-built_in">rand</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    siz[i]++;<br>    <span class="hljs-keyword">if</span> (x &lt;= val[i])<br>    &#123;<br>        <span class="hljs-built_in">ins</span>(x, <span class="hljs-built_in">ls</span>(i));<br>        <span class="hljs-keyword">if</span> (pri[<span class="hljs-built_in">ls</span>(i)] &lt; pri[i])<br>            <span class="hljs-built_in">spin</span>(i, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">ins</span>(x, <span class="hljs-built_in">rs</span>(i));<br>        <span class="hljs-keyword">if</span> (pri[<span class="hljs-built_in">rs</span>(i)] &lt; pri[i])<br>            <span class="hljs-built_in">spin</span>(i, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x == val[i])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ls</span>(i) * <span class="hljs-built_in">rs</span>(i) == <span class="hljs-number">0</span>)<br>        &#123;<br>            i = son[i][<span class="hljs-number">0</span>] + son[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pri[<span class="hljs-built_in">ls</span>(i)] &gt; pri[<span class="hljs-built_in">rs</span>(i)])<br>        &#123;<br>            <span class="hljs-built_in">spin</span>(i, <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">del</span>(x, <span class="hljs-built_in">ls</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">spin</span>(i, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">del</span>(x, <span class="hljs-built_in">rs</span>(i));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[i] &gt; x)<br>        <span class="hljs-built_in">del</span>(x, <span class="hljs-built_in">ls</span>(i));<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">del</span>(x, <span class="hljs-built_in">rs</span>(i));<br><br>    <span class="hljs-built_in">up</span>(i);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">rk</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (val[i] &gt;= x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rk</span>(x, <span class="hljs-built_in">ls</span>(i));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rk</span>(x, <span class="hljs-built_in">rs</span>(i)) + siz[<span class="hljs-built_in">ls</span>(i)] + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (siz[<span class="hljs-built_in">ls</span>(i)] == x - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> w[i];<br>    <span class="hljs-keyword">if</span> (siz[<span class="hljs-built_in">ls</span>(i)] &gt;= x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(x, <span class="hljs-built_in">ls</span>(i));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x - siz[<span class="hljs-built_in">ls</span>(i)] - <span class="hljs-number">1</span>, <span class="hljs-built_in">rs</span>(i));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!i)<br>        <span class="hljs-keyword">return</span> -inf;<br>    <span class="hljs-keyword">if</span> (val[i] &lt; x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(val[i], <span class="hljs-built_in">pre</span>(x, <span class="hljs-built_in">rs</span>(i)));<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(x, <span class="hljs-built_in">ls</span>(i));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">nxt</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!i)<br>        <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-keyword">if</span> (val[i] &gt; x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(val[i], <span class="hljs-built_in">nxt</span>(x, <span class="hljs-built_in">ls</span>(i)));<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">nxt</span>(x, <span class="hljs-built_in">rs</span>(i));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="fhq-treap"><a class="markdownIt-Anchor" href="#fhq-treap"></a> FHQ Treap</h3>
<p>即无旋Treap。</p>
<p>现在我们不旋转了，换用分裂与合并去维护树的特性。</p>
<p>就是把树拆开，拼上，再拆开，再拼上。</p>
<p>那么我们需要存储五种信息，左右子树编号，权值，子树大小，索引。</p>
<p>分裂分为两种，分别为按值分裂与按大小分裂。</p>
<p>在通常情况下，FHQ仅发挥平衡树功能时，我们按值分裂，当维护区间信息时我们就需要去按照大小分裂，即文艺平衡树。</p>
<p>合并时就一种，即把两棵树合二为一，其中一树上的所有权值都需要小于另一棵待合并的树，以此来维持Treap的性质。</p>
<p>首先来说插入。</p>
<p>那么我们要插入它，肯定是按照插入值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 来分类，得到一棵权值全部大于它的树与另一棵权值全部小于它的树，那么我们直接合并 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 新建的节点，最后并上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 就大功告成。</p>
<p>再说删除。</p>
<p>我们还是先按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 分裂成两棵树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>，再按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">val-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 把其中一棵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 分裂为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。那么我们可以得到三棵树，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 上所有权值都会等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>。那么我们删除它的根结点，让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 等于合并 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的左子树与有字数，最后再合并上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。</p>
<p>前驱的话直接按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">val-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 分裂，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>里最右的数即为前驱。</p>
<p>后继同样，按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>分裂，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>中最左的数即为后继。</p>
<p>至于建树，我们发现Treap其实是笛卡尔树，那么我们直接利用笛卡尔树<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>建树方法即可，即单调栈维护右链。</p>
<h5 id="fhq的区间操作"><a class="markdownIt-Anchor" href="#fhq的区间操作"></a> FHQ的区间操作</h5>
<p>相比于带旋Treap来说，FHQ的一个特点就是可以实现各种区间操作。我们以文艺平衡树为例来介绍各种区间操作。</p>
<p>文艺平衡树的特别之处就是需要提供一个区间翻转操作，那么我们首先考虑去建树，建出来的树需要是我们最初始的区间。</p>
<p>那么我们只需要把区间下标以此地插入Treap，那么中序遍历之后我们就能方便地得到这个区间。</p>
<p>但是Treap还会根据堆的性质来调整树的结构，如何确保中序遍历正确输出就是我们亟需解决的一个问题。</p>
<p>其实我们还是可以参考笛卡尔树的单调栈建树方法来解决它。</p>
<p>那么我们设新插入的节点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，每一个新插入的节点一定会被连到Treap的右链中。</p>
<p>从根结点开始，右链上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ord</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 显然是递增的，那么我们可在此链上找到第一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ord</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 节点，我们称之为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，并且把它替换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。</p>
<p>又因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定会大于树上的其它全部节点，我们需要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>及其子树作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的左子树，并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 此时并没有右子树。</p>
<p>那么显然中序遍历时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定为最后一个被遍历的。</p>
<p><img src="https://oi-wiki.org/ds/images/treap-none-rot-seg-build.svg" alt="" /></p>
<h5 id="区间翻转"><a class="markdownIt-Anchor" href="#区间翻转"></a> 区间翻转</h5>
<p>我们需要翻转 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>,那么基本思路是把树分裂成 $[1,l-1],[l,r],[r+1,n] $ 三个区间，再对中间的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 进行翻转操作。</p>
<p>翻转的具体操作其实就是把区间内子树的每一个左右儿子都交换位置。</p>
<p>如图,就是翻转了上图的Treap：</p>
<p><img src="https://oi-wiki.org/ds/images/treap-none-rot-seg-flip-ex.svg" alt="" /></p>
<p>如果翻转是这个方式，那么每次翻转区间时，都会有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个区间被交换位置，时间复杂度会很高，如何处理？</p>
<p>我们回想一下在线段树遇到这种情况时是怎么处理的？显然，Lazy Tag即可解决问题。</p>
<p>我们只需要在父节点打上标记，那么就可以代表整课子树的左右子节点都要交换。</p>
<p>同时要注意我们应该在分裂时下传标记，又因合并需要分裂，那么合并前也需要下传。</p>
<p>那么，我们就是在树的结构改变时，我们需要进行分裂或者合并操作时，需要改变某个点的左右儿子信息时，操作之前也应下传标记。</p>
<p>没了。</p>
<p>（代码不是我的）</p>
<p>FHQ Treap</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> son[N][<span class="hljs-number">3</span>],val[N],ran[N],siz[N],SIZE,n,root,x,y,z,opt,a;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;siz[x]=<span class="hljs-number">1</span>+siz[son[x][<span class="hljs-number">0</span>]]+siz[son[x][<span class="hljs-number">1</span>]];&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>	siz[++SIZE]=<span class="hljs-number">1</span>;<br>	val[SIZE]=v;ran[SIZE]=<span class="hljs-built_in">rand</span>();<br>	<span class="hljs-keyword">return</span> SIZE;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!x||!y) <span class="hljs-keyword">return</span> x+y;<br>	<span class="hljs-keyword">if</span>(ran[x]&lt;ran[y])&#123;<br>		son[x][<span class="hljs-number">1</span>]=<span class="hljs-built_in">merge</span>(son[x][<span class="hljs-number">1</span>],y);<br>		<span class="hljs-built_in">Up</span>(x);<span class="hljs-keyword">return</span> x;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		son[y][<span class="hljs-number">0</span>]=<span class="hljs-built_in">merge</span>(x,son[y][<span class="hljs-number">0</span>]);<br>		<span class="hljs-built_in">Up</span>(y);<span class="hljs-keyword">return</span> y;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!p) x=y=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">if</span>(val[p]&lt;=k) x=p,<span class="hljs-built_in">split</span>(son[p][<span class="hljs-number">1</span>],k,son[p][<span class="hljs-number">1</span>],y);<br>		<span class="hljs-keyword">else</span> y=p,<span class="hljs-built_in">split</span>(son[p][<span class="hljs-number">0</span>],k,x,son[p][<span class="hljs-number">0</span>]);<br>		<span class="hljs-built_in">Up</span>(p);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-keyword">if</span>(k&lt;=siz[son[p][<span class="hljs-number">0</span>]])p=son[p][<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==siz[son[p][<span class="hljs-number">0</span>]]+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> p;<br>		<span class="hljs-keyword">else</span> k-=siz[son[p][<span class="hljs-number">0</span>]]+<span class="hljs-number">1</span>,p=son[p][<span class="hljs-number">1</span>];<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">srand</span>(<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>);<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;opt,&amp;a);<br>		<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//插入 </span><br>			<span class="hljs-built_in">split</span>(root,a,x,y);<br>			root=<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x,<span class="hljs-built_in">New</span>(a)),y);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>)&#123;<br>			<span class="hljs-built_in">split</span>(root,a,x,z);<span class="hljs-built_in">split</span>(x,a<span class="hljs-number">-1</span>,x,y);<br>			y=<span class="hljs-built_in">merge</span>(son[y][<span class="hljs-number">0</span>],son[y][<span class="hljs-number">1</span>]);root=<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x,y),z);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">3</span>)&#123;<br>			<span class="hljs-built_in">split</span>(root,a<span class="hljs-number">-1</span>,x,y);<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,siz[x]+<span class="hljs-number">1</span>);<br>			root=<span class="hljs-built_in">merge</span>(x,y);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">4</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,val[<span class="hljs-built_in">kth</span>(root,a)]);&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">5</span>)&#123;<br>			<span class="hljs-built_in">split</span>(root,a<span class="hljs-number">-1</span>,x,y);<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,val[<span class="hljs-built_in">kth</span>(x,siz[x])]);<br>			root=<span class="hljs-built_in">merge</span>(x,y);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">6</span>)&#123;<br>			<span class="hljs-built_in">split</span>(root,a,x,y);<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,val[<span class="hljs-built_in">kth</span>(y,<span class="hljs-number">1</span>)]);<br>			root=<span class="hljs-built_in">merge</span>(x,y);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>FHQ Treap区间操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> son[N][<span class="hljs-number">3</span>],val[N],ran[N],siz[N],SIZE,n,root,m;<br><span class="hljs-type">bool</span> f[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;siz[x]=<span class="hljs-number">1</span>+siz[son[x][<span class="hljs-number">0</span>]]+siz[son[x][<span class="hljs-number">1</span>]];&#125; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-built_in">swap</span>(son[x][<span class="hljs-number">0</span>],son[x][<span class="hljs-number">1</span>]);<br>	<span class="hljs-keyword">if</span>(son[x][<span class="hljs-number">0</span>])f[son[x][<span class="hljs-number">0</span>]]^=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(son[x][<span class="hljs-number">1</span>])f[son[x][<span class="hljs-number">1</span>]]^=<span class="hljs-number">1</span>;<br>	f[x]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>	siz[++SIZE]=<span class="hljs-number">1</span>;<br>	val[SIZE]=v;ran[SIZE]=<span class="hljs-built_in">rand</span>();<br>	<span class="hljs-keyword">return</span> SIZE;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!x||!y) <span class="hljs-keyword">return</span> x+y;<br>	<span class="hljs-keyword">if</span>(ran[x]&lt;ran[y])&#123;<br>		<span class="hljs-keyword">if</span>(f[x])<span class="hljs-built_in">Down</span>(x);<br>		son[x][<span class="hljs-number">1</span>]=<span class="hljs-built_in">merge</span>(son[x][<span class="hljs-number">1</span>],y);<br>		<span class="hljs-built_in">Up</span>(x);<span class="hljs-keyword">return</span> x;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span>(f[y])<span class="hljs-built_in">Down</span>(y);<br>		son[y][<span class="hljs-number">0</span>]=<span class="hljs-built_in">merge</span>(x,son[y][<span class="hljs-number">0</span>]);<br>		<span class="hljs-built_in">Up</span>(y);<span class="hljs-keyword">return</span> y;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!p) x=y=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">if</span>(f[p])<span class="hljs-built_in">Down</span>(p);<span class="hljs-comment">//下面用siz，而不是val </span><br>		<span class="hljs-keyword">if</span>(siz[son[p][<span class="hljs-number">0</span>]]&lt;k) x=p,<span class="hljs-built_in">split</span>(son[p][<span class="hljs-number">1</span>],k-siz[son[p][<span class="hljs-number">0</span>]]<span class="hljs-number">-1</span>,son[p][<span class="hljs-number">1</span>],y);<br>		<span class="hljs-keyword">else</span> y=p,<span class="hljs-built_in">split</span>(son[p][<span class="hljs-number">0</span>],k,x,son[p][<span class="hljs-number">0</span>]);<br>		<span class="hljs-built_in">Up</span>(p);<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*int kth(int p,int k)&#123;</span><br><span class="hljs-comment">	while(1)&#123;</span><br><span class="hljs-comment">		if(k&lt;=siz[son[p][0]])p=son[p][0];</span><br><span class="hljs-comment">		else if(k==siz[son[p][0]]+1) return p;</span><br><span class="hljs-comment">		else k-=siz[son[p][0]]+1,p=son[p][1];</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> ;<br>	<span class="hljs-keyword">if</span>(f[x])<span class="hljs-built_in">Down</span>(x);<br>	<span class="hljs-built_in">out</span>(son[x][<span class="hljs-number">0</span>]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,val[x]) ;<br>	<span class="hljs-built_in">out</span>(son[x][<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)root=<span class="hljs-built_in">merge</span>(root,<span class="hljs-built_in">New</span>(i));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-type">int</span> l,r,x,y,z;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>		<span class="hljs-built_in">split</span>(root,l<span class="hljs-number">-1</span>,x,y);<span class="hljs-built_in">split</span>(y,r-l+<span class="hljs-number">1</span>,y,z);<br>		f[y]^=<span class="hljs-number">1</span>;root=<span class="hljs-built_in">merge</span>(x,<span class="hljs-built_in">merge</span>(y,z));<br>	&#125;<br>	<span class="hljs-built_in">out</span>(root);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>没了。</p>
<h1 id="动态树"><a class="markdownIt-Anchor" href="#动态树"></a> 动态树</h1>
<h2 id="lct"><a class="markdownIt-Anchor" href="#lct"></a> LCT</h2>
<p>如果我们需要维护一棵树，支持链上求和、链上求最值、链上修改、子树修改、子树求和，那么我们可以用树剖轻松地过掉。</p>
<p>那如果我们要额外支持换根、断边、连点这几个操作呢？显然树剖就不太够看了。因为树剖是静态的，不能加边或者删边。</p>
<p>怎么解决？LCT即可。</p>
<p>没错，就是LinkCutTree。</p>
<p>它用来解决动态树问题，即带修改边的树剖，其本质是利用虚实链剖分去维护。</p>
<p>一个节点最多会连出一条实边指向儿子，因此实边必定会聚成实链。那么根据树剖的思想，我们也需要一个数据结构去维护动态的东西——平衡树！</p>
<p>我们这里选用Splay去维护。</p>
<p>它与轻重链剖分最大的不同在于重链是偏静态的，但是偏路径是动态的。</p>
<p>LCT维护的对象本质上是一片森林，都是由纯虚边或者纯实边构成的<s>纯种</s>树。</p>
<p>由此LCT会有一些神奇的性质:<br />
1.每一个Splay都是维护的一条从上到下的路径，且在原树中的深度会单调递增。那么显然，同一棵Splay中不会有同一层的节点，即一个父亲的儿子里最多只会存在一个在包含父亲的Splay中。<br />
2.每个节点包含且仅包含于一个Splay中，即各个Splay的点集不存在交集。<br />
3.实边会包含在Splay中，虚边总是由一棵Splay指向它中序遍历最靠前的点在原树里的父亲。</p>
<p>那么为了保持树的形态，我们要让父节点指向其它子节点的边为虚边，但是其它子节点会指向父节点，即认父不认子。</p>
<p>各种操作：</p>
<h4 id="accessx"><a class="markdownIt-Anchor" href="#accessx"></a> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">access(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></h4>
<p>为LCT核心操作，用来变换虚实边。</p>
<p>由于其性质3,我们并不能保证两个点路径会直接连通。那么我们此时就需要一个操作来打通树的任通二脉，让我们指定的节点之间存在一条通路。</p>
<p>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span>就应运而生了，它定义为打通根结点到指定节点的实链，使一个中序遍历从根结点开始，到指定节点停止的Spaly被构造。</p>
<p>我们放几个图（偷得：</p>
<p><img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123095924037-1618037447.png" alt="" /></p>
<p>这是树的开始状态，我们给他划分一下Splay：</p>
<p><img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123095955350-1680422636.png" alt="" /></p>
<p>假设我们需要把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>打通，那么其他的链都要给它让路，也就是变成下图：</p>
<p><img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123101901740-2118178734.png" alt="" /></p>
<p>如何实现？模拟即可。</p>
<p>首先把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>变成根，再把原来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mi>O</mi></mrow><annotation encoding="application/x-tex">N-O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>的边变为虚边。又为了保证深度严格单调，我在Splay中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的右子树里，那么直接把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的右子节点变为0：<br />
<img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110136115-1112016464.png" alt="" /></p>
<p>之后再把其他碍事的玩意都干掉就行<br />
<img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110156272-1242463729.png" alt="" /><br />
<img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110209772-2057141058.png" alt="" /><br />
<img src="https://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110213709-49169640.png" alt="" /><br />
好了，成功了。</p>
<p>代码实现也不难，只需要转到根，换子节点，更新，再把当前点切换为虚边指向的父节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;x;v=x,x=f[x])<br>		<span class="hljs-built_in">splay</span>(x),<span class="hljs-built_in">rs</span>(x)=v,<span class="hljs-built_in">up</span>(x);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="makerootx"><a class="markdownIt-Anchor" href="#makerootx"></a> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">makeroot(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></h4>
<p>仅仅把某条路径拉起来并不能实现我们的需求，那么我们需要得到两个节点之间的路径信息。</p>
<p>然而这俩点不一定是同一链上，那么我们可以换根，使指定的节点成为原树的根，就可以快速地利用性质处理了。</p>
<p>我们需要借助一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">access(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 和Splay的翻转的操作来实现。</p>
<p>打通道路后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>一定是Splay中中序遍历的最后一个点，那么我们转上去后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>在Splay里会没有右子树。那么我们翻转整个Splay，使得所有点的深度也翻转，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>没了左子树，就会变成深度最小的点，即根结点，那么就实现了换根的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(<span class="hljs-built_in">ls</span>(x),<span class="hljs-built_in">rs</span>(x));<br>    tagr[x]^=<span class="hljs-number">1</span>;<span class="hljs-comment">//翻转的LazyTag</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-built_in">reverse</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="findroot"><a class="markdownIt-Anchor" href="#findroot"></a> findroot</h4>
<p>即找某点所在树的根，主要用于判断两点是否连通。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x); <br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">ls</span>(x))<span class="hljs-built_in">down</span>(x),x=<span class="hljs-built_in">ls</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="split"><a class="markdownIt-Anchor" href="#split"></a> split</h4>
<p>定义为从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-&gt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 拉出一条路径成为一个Splay。(这里让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 作为Splay的根，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 作为原树的根)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">makeroot</span>(x);<br>    <span class="hljs-built_in">access</span>(y);<br>    <span class="hljs-built_in">splay</span>(y);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么路径就可以直接用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span> 得到，而把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 转到Splay根之后，我们可以直接访问它来获得有关信息。</p>
<h4 id="link"><a class="markdownIt-Anchor" href="#link"></a> link</h4>
<p>连边（使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-&gt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，虚边）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">makeroot</span>(x);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y)==x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    f[x]=y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里布尔返回值是判断连边是否合法。</p>
<h4 id="cut"><a class="markdownIt-Anchor" href="#cut"></a> cut</h4>
<p>断边。</p>
<p>如果保证合法，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">split</span>(x,y);<br>    f[x]=<span class="hljs-built_in">ls</span>(y)=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">up</span>(y);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果不保证，我们会利用性质：</p>
<p>先判断连通性(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>变成根了)，再看是否有父子关系，再看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是否有左子节点。</p>
<p>因为在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">access(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 之后，如果两点在同一Splay但是没有直接的边，那么中间会有别的边，且中序遍历时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 直接会有别的边。</p>
<p>所以需要满足三个条件才可断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">makeroot</span>(x);<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y)!=x||f[y]!=x||<span class="hljs-built_in">ls</span>(y))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	f[y]=<span class="hljs-built_in">rs</span>(x)=<span class="hljs-number">0</span>;<span class="hljs-comment">//x在findroot(y)后被转到了根</span><br>	<span class="hljs-built_in">up</span>(x);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么LCT中的Splay操作也会有些细节不大寻常，可以用下面更稳妥的方法写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tagr[x])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ls</span>(x))<br>            <span class="hljs-built_in">resver</span>(<span class="hljs-built_in">ls</span>(x));<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">rs</span>(x))<br>            <span class="hljs-built_in">resver</span>(<span class="hljs-built_in">rs</span>(x));<br>        tagr[x]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-built_in">pushr</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基础操作没了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ONLINE_JUDGE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>], *p1 = buf, *p2 = buf;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            flag = <span class="hljs-number">-1</span>;<br>        c = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>        ret = ret * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>, c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> ret * flag;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Maxn = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(x) son[x][0]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(x) son[x][1]</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> rt;<br><span class="hljs-type">int</span> son[Maxn][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> f[Maxn], val[Maxn];<br><span class="hljs-type">int</span> s[Maxn], st[Maxn];<br><span class="hljs-type">int</span> v[Maxn];<br><span class="hljs-type">bool</span> r[Maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">nrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ls</span>(f[x]) == x <span class="hljs-keyword">or</span> <span class="hljs-built_in">rs</span>(f[x]) == x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    s[x] = s[<span class="hljs-built_in">ls</span>(x)] ^ s[<span class="hljs-built_in">rs</span>(x)] ^ v[x];<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(<span class="hljs-built_in">ls</span>(x), <span class="hljs-built_in">rs</span>(x));<br>    r[x] ^= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (r[x])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ls</span>(x))<br>            <span class="hljs-built_in">rev</span>(<span class="hljs-built_in">ls</span>(x));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rs</span>(x))<br>            <span class="hljs-built_in">rev</span>(<span class="hljs-built_in">rs</span>(x));<br>        r[x] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = f[x], z = f[y];<br>    <span class="hljs-type">int</span> k = (<span class="hljs-built_in">rs</span>(y) == x), w = son[x][!k];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y))<br>        son[z][<span class="hljs-built_in">rs</span>(z) == y] = x;<br>    son[x][!k] = y;<br>    son[y][k] = w;<br>    <span class="hljs-keyword">if</span> (w)<br>        f[w] = y;<br>    f[y] = x, f[x] = z;<br>    <span class="hljs-built_in">up</span>(y);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = x, t = <span class="hljs-number">0</span>;<br>    st[++t] = y;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nrt</span>(y))<br>        st[++t] = y = f[y];<br>    <span class="hljs-keyword">while</span> (t)<br>        <span class="hljs-built_in">down</span>(st[t--]);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nrt</span>(x))<br>    &#123;<br>        y = f[x];<br>        t = f[y];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y))<br>            <span class="hljs-built_in">rotate</span>((<span class="hljs-built_in">ls</span>(y) == x) ^ ((<span class="hljs-built_in">ls</span>(t) == y)) ? x : y);<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">up</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; x; x = f[y = x])<br>    &#123;<br>        <span class="hljs-built_in">splay</span>(x), <span class="hljs-built_in">rs</span>(x) = y;<br>        <span class="hljs-built_in">up</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">makert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-built_in">rev</span>(x);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">findrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">ls</span>(x))<br>        <span class="hljs-built_in">down</span>(x), x = <span class="hljs-built_in">ls</span>(x);<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">makert</span>(x);<br>    <span class="hljs-built_in">access</span>(y);<br>    <span class="hljs-built_in">splay</span>(y);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">makert</span>(x);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findrt</span>(y) != x)<br>        f[x] = y;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">makert</span>(x);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findrt</span>(y) == x <span class="hljs-keyword">and</span> f[y] == x <span class="hljs-keyword">and</span> !<span class="hljs-built_in">ls</span>(y))<br>    &#123;<br>        f[y] = <span class="hljs-built_in">rs</span>(x) = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">up</span>(x);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        v[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> opt = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">split</span>(x, y), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[y]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">link</span>(x, y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>)<br>            <span class="hljs-built_in">cut</span>(x, y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>)<br>            <span class="hljs-built_in">splay</span>(x), v[x] = y;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
      </section>

      
      
        <nav class="article-nav">
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="https://cdn.luogu.com.cn/upload/image_hosting/2ftetr9n.png"></div>
    
    <div class="card-text">
      
        <a href="/2022/07/22/Min25%E7%AD%9B/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">Min25筛</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="https://cdn.luogu.com.cn/upload/image_hosting/vj8obimb.png" class="soft-size--round soft-style--box" alt="Ztemily">
    
    
      <h2>Ztemily</h2>
    
    
      <p>此后如竟没有炬火，我们便是唯一的光。</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>5</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        0
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        1
      </div>
    </div>
  </div>
</section>

      

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>新搭建的博客，欢迎来玩~</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/OI/" style="font-size: 10px;" class="tags-cloud-0">OI</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/ztemil/" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">Ztemily</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->




  


  


  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>
